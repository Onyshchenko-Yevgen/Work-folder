1)Опишите работу трех основных флагов в регулярных выражениях.

g (global) ? не возвращает результат после первого совпадения, а продолжает поиск с конца предыдущего совпадения.
m (multi line) ? с таким флагом, операторы ^ и $ вызовут совпадение в начале и конце строки ввода (line), вместо строки целиком (string).
i (insensitive) ? делает выражение регистронезависимым (например, /aBc/i соответствует AbC).

2)В чем отличие классов \w \W \s \S \d \D друг от друга?

У операторов \d, \w и \s также есть отрицания ? \D, \W и \S соответственно.
Например, оператор \D будет искать соответствия противоположенные \d.

3)Итак квантификаторы — это метасимволы, позволяющие задать количество повторений символа или группы символов в строке.

Доступны нам следующие квантификаторы:

* — любое кол-во вхождений предшествующего символа

+ — одно или более вхождений предшествующего символа

? — указывает на необязательность предшествующего символа

{n} — точное кол-во вхождений предшествующего символа

{n,} — минимальное кол-во вхождений предшествующего символа

{n,m} — возможно кол-во вхождений предшествующего символа от n до m

4)Что такое группировка и обратные ссылки в регулярных выражениях?

Круглые скобки имеют в регулярных выражениях несколько значений. Одно из них - группировка отдельных элементов в одно подвыражение, так что элементы при использовании специальных символов |, *, +, ? и других рассматриваются как одно целое. Например, шаблон /java(script)?/ соответствует слову «java», за которым следует необязательное слово «script», а /(ab|cd)+|ef)/ соответствует либо строке «ef», либо одному или более повторений одной из строк «ab» или «cd».

Обратные ссылки предоставляют удобный способ идентификации повторяющегося символа или подстроки в строке. Например, если входная строка содержит несколько экземпляров произвольной подстроки, можно найти первое вхождение с помощью группы записи, а затем использовать обратную ссылку для поиска последующих вхождений подстроки.

Для того, чтобы шаблон искал закрывающую кавычку такую же, как и открывающую, обернём открывающие кавычки в скобочную группу и используем обратную ссылку на неё: (['"])(.*?)\1.
let str = `He said: "She's the one!".`;

let regexp = /(['"])(.*?)\1/g;

alert( str.match(regexp) ); // "She's the one!"

Движок регулярных выражений находит первую кавычку из шаблона (['"]) и запоминает её содержимое. Это первая скобочная группа.

Далее в шаблоне \1 означает «найти то же самое, что в первой скобочной группе», а именно – аналогичную кавычку в нашем случае.

Аналогично, \2 означает содержимое второй скобочной группы, \3 – третьей, и так далее.

5)Опишите методы строк, которые используют регулярные выражения.

-str.split(regexp|substr, limit)
Разбивает строку в массив по разделителю – регулярному выражению regexp или подстроке substr
alert('12, 34, 56'.split(/,\s*/)) // массив [12, 34, 56]

-Метод str.search(regexp) возвращает позицию первого совпадения с regexp в строке str или -1, если совпадения нет.
let str = "Я люблю JavaScript!";

let regexp = /Java.+/;

alert( str.search(regexp) ); // 8

-str.replace(str|regexp, str|func)
Это универсальный метод поиска-и-замены, один из самых полезных. Этакий швейцарский армейский нож для поиска и замены в строке.
// заменить тире двоеточием
alert('12-34-56'.replace("-", ":")) // 12:34-56


6)Опишите методы самих регулярных выражений на совпадение и поиск данных в строке.

-Метод str.match(regexp) ищет совпадения с regexp в строке str.
let str = "I love JavaScript";

let result = str.match(/Java(Script)/);

alert( result[0] );     // JavaScript (всё совпадение)
alert( result[1] );     // Script (первые скобки)
alert( result.length ); // 2

// Дополнительная информация:
alert( result.index );  // 7 (позиция совпадения)
alert( result.input );  // I love JavaScript (исходная строка)

-Метод str.matchAll(regexp) – «новый, улучшенный» вариант метода str.match.

Он используется, в первую очередь, для поиска всех совпадений вместе со скобочными группами.

У него 3 отличия от match:

Он возвращает не массив, а перебираемый объект с результатами, обычный массив можно сделать при помощи Array.from.
Каждое совпадение возвращается в виде массива со скобочными группами (как str.match без флага g).
Если совпадений нет, то возвращается не null, а пустой перебираемый объект.
Пример использования:

 let str = '<h1>Hello, world!</h1>';
let regexp = /<(.*?)>/g;

let matchAll = str.matchAll(regexp);

alert(matchAll); // [object RegExp String Iterator], не массив, а перебираемый объект

matchAll = Array.from(matchAll); // теперь массив

let firstMatch = matchAll[0];
alert( firstMatch[0] );  // <h1>
alert( firstMatch[1] );  // h1
alert( firstMatch.index );  // 0
alert( firstMatch.input );  // <h1>Hello, world!</h1>


